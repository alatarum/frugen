/** @file
 *  @brief Header for FRU information helper functions
 *
 *  @copyright
 *  Copyright (C) 2016-2024 Alexander Amelkin <alexander@amelkin.msk.ru>
 *
 *  SPDX-License-Identifier: GPL-2.0-or-later OR Apache-2.0
 */

#pragma once

/**
 * @addtogroup common
 * @brief Common definitions for the library
 *
 * @{
 */
#define LIBFRU_MAJOR    @PROJECT_VERSION_MAJOR@L ///< Major component of the library version
#define LIBFRU_MINOR    @PROJECT_VERSION_MINOR@L ///< Minor component of the library version
#define LIBFRU_SUBMINOR @PROJECT_VERSION_PATCH@L ///< Subminor component of the library version
/**
 * @brief Integer representation of the library version
 *
 * You may use this as a feature test macro, e.g.:
 * ```c
 * #if (LIBFRU_VERSION >= 0x020000) // Library is at least version 2.0.0
 * // Do something
 * #endif
 * ```
 */
#define LIBFRU_VERSION  (LIBFRU_MAJOR << 16 | \
                         LIBFRU_MINOR << 8 | \
                         LIBFRU_SUBMINOR)

/*
 * Private macro definitions.
 *
 * These macros aren't for library users, but they are needed for public
 * interfaces definition.
 *
 * @cond PRIVATE
 */

#define FRU__ARRAY_SZ(a) (sizeof(a) / sizeof((a)[0]))
#define FRU__BIT(x) (1 << (x))

#define FRU__TYPE_BITS_MASK    0xC0
#define FRU__FIELDLEN(x)   ((size_t)(((x) & ~FRU__TYPE_BITS_MASK)))

/** For binary/encoded FRU fields.
 *  You definitely don't need to directly use this.
 */
#define FRU__FIELDMAXLEN       FRU__FIELDLEN(UINT8_MAX)
/** @endcond */

/** For C-string allocation.
 *
 * You probably don't need to directly use this, prefer
 * using \p fru_field_t type:
 *
 * ```c
 * fru_field_t field;
 * 
 * if (strlen(mystring) >= sizeof(field.val)) {
 *     // Smells like buffer overflow
 * }
 * ```
 *
 * Better yet, use \p fru_set_field() that performs the required
 * checks itself.
 */
// BCD+ decoded data is twice the length of encoded,
// so is hex string for binary data
#define FRU_FIELDMAXARRAY     ((2 * FRU__FIELDMAXLEN) + 1)

/*
 * Public macro definitions
 */

/** @} */

/**
 * @addtogroup barea
 * @brief Definitions related to Board Info Area
 *
 * @{
 */

/**
 * @brief Language code definitions as per IPMI FRU
 *        Specification, Table 15-1.
 */
typedef enum {
    LANG_DEFAULT = 0,  /**< Default Language code, implies
                        *   English as per Table 15-1 */
    LANG_ENGLISH = 25, /**< English language code */
} fru_lang_t;

/** @} */

/*
 * Public type definitions
 */

/**
 * @addtogroup common
 */

/**
 * @brief FRU area types
 *
 * Also area indices inside the FRU information structure header
 */
typedef enum {
	FRU_INTERNAL_USE, /**< Internal use area */
	FRU_MIN_AREA = FRU_INTERNAL_USE, /**< Minimum area type (equals \ref FRU_INTERNAL_USE) */
	FRU_CHASSIS_INFO, /**< Chassis information area */
	FRU_BOARD_INFO, /**< Board information area */
	FRU_PRODUCT_INFO, /**< Product information area */
	FRU_MR_AREA, /**< Multirecord area */
	FRU_MAX_AREA = FRU_MR_AREA, /**< Maximum area type (equals \ref FRU_MR_AREA) */
	FRU_TOTAL_AREAS /**< Maximum total count of areas in a FRU file */
} fru_area_type_t;
#define FRU_INFO_AREAS 3 /**< Number of standard 'info' areas */
#define FRU_FIRST_INFO_AREA FRU_CHASSIS_INFO /**< Index of the first 'info' area */

/**
 * @brief Field encoding type.
 *
 * This enum contains values as per Section 13 of IPMI FRU Specification,
 * as well as some extensions used solely by the functions of this
 * library and not saved into the output binary file or buffer.
 *
 * The \a standard values are positive, anything less than \p FIELD_TYPE_AUTO
 * is an extension.
 */
typedef enum {
	FIELD_TYPE_UNKNOWN = -1, ///< Field encoding type couldn't be detected or wasn't set
	FIELD_TYPE_PRESERVE = FIELD_TYPE_UNKNOWN, /**< Preserve the field encoding as it was,
	                                           *   fail if impossible. This is a virtual encoding
	                                           *   type for use with fru_setfield() only */
	FIELD_TYPE_AUTO = FIELD_TYPE_MIN, /**< When packing, detect the encoding type
	                                   *   automatically based on the input text range */
	FIELD_TYPE_EMPTY = FIELD_TYPE_AUTO, ///< The field is empty \todo Shouldn't this be fru_errno?
	FIELD_TYPE_BINARY = (FRU__TYPE_BINARY + 1), /**< Encode the field as binary, the value
	                                             *   is a hex string (e.g. \p "1337C0DE") */
	FIELD_TYPE_MIN = FIELD_TYPE_BINARY, ///< The minumum non-auto (real) encoding
	FIELD_TYPE_BCDPLUS = (FRU__TYPE_BCDPLUS + 1), /**< Encode the field as BCD+, the value
	                                               *   may only contain digits 0-9, space, dash,
	                                               *   or period. */
	FIELD_TYPE_6BITASCII = (FRU__TYPE_ASCII_6BIT + 1), /**< Encode the field as 6-bit ASCII,
	                                                    *   the value may only contain characters
	                                                    *   per Table 13-1 of IPMI FRU Specification */
	FIELD_TYPE_TEXT = (FRU__TYPE_TEXT + 1), /**< Encode the field as plain text (ASCII+Latin1).
	                                         *   Only English is currently supported,
	                                         *   see Section 13 of IPMI FRU Specification */
	FIELD_TYPE_MAX = FIELD_TYPE_TEXT, /**< Maximim valid 'real' field type */
	TOTAL_FIELD_TYPES ///< Total count of \a standard field types (not including the negative extensions)
} fru_field_type_t;

/**
 * @brief A generic input (decoded) field structure.
 *
 * Containis the FRU field encoding type as well as the
 * field value as a string.
 *
 * You probably don't want to set this manually. Prefer
 * the \p fru_setfield() function instead as it performs
 * additional checks.
 */
typedef struct {
	fru_field_type_t type; /**< The encoding type of the field.
	                        *
	                        * Takes any of the \p field_type_t values
	                        */
	char val[FRU_FIELDMAXARRAY]; ///< The decoded C-string representation of the field value
} fru_field_t;

/**
 * @brief A single-linked list of decoded FRU area fields.
 *
 * This is used to describe any length chains of fields.
 * Mandatory fields are linked first in the order they appear
 * in the information area (as per Specification), then custom
 * fields are linked.
 */
typedef struct fru_reclist_s {
	fru_field_t *rec; ///< A pointer to a field or NULL if not initialized
	struct fru_reclist_s *next; ///< The next record in the list or NULL if last
} fru_reclist_t;

/**
 * @addtogroup carea Chassis area
 * @brief Definitions related to Chassis Info Area
 *
 * @{
 */

/**
 * @brief The exploded representation of chassis info area
 *
 * Contains fields as per IPMI FRU Specification Table 10-1,
 * in their decoded state
 */
typedef struct {
	uint8_t type; ///< Chassis type as per SMBIOS specification
	fru_field_t pn; ///< Part Number
	fru_field_t serial; ///< Serial Number
	fru_reclist_t *cust; ///< Linked list of custom fields
} fru_chassis_t;
/** @} */

/**
 * @addtogroup barea Board area
 *
 * @{
 */

/**
 * @brief The exploded representation of board info area.
 *
 * Contains fields as per IPMI FRU Specification Table 11-1,
 * in their decoded state
 */
typedef struct {
	fru_lang_t lang; ///< Language code
	struct timeval tv; ///< Manufacturing date/time, in UTC
	fru_field_t mfg; ///< Board manufacturer name
	fru_field_t pname; ///< Board product name
	fru_field_t serial; ///< Board serial number
	fru_field_t pn; ///< Board part number
	fru_field_t file; ///< FRU File ID
	fru_reclist_t *cust; ///< Linked list of custom fields
	bool tv_auto; ///< On encoding, use current date/time
} fru_board_t;
/** @} */

/**
 * @addtogroup parea Product area
 * @brief Definitions related to Product Info Area
 *
 * @{
 */

/**
 * @brief The exploded representation of product info area
 *
 * Contains fields as per IPMI FRU Specification Table 12-1,
 * in their decoded state
 */
typedef struct {
	uint8_t lang;
	fru_field_t mfg; ///< Product manufacturer
	fru_field_t pname; ///< Product name
	fru_field_t pn; ///< Product part number
	fru_field_t ver; ///< Product version
	fru_field_t serial; ///< Product serial number
	fru_field_t atag; ///< Product asset tag
	fru_field_t file; ///< FRU File ID
	fru_reclist_t *cust; ///< Linked list of custom fields
} fru_product_t;
/** @} */

/**
 * @brief Exploded/decoded FRU data structure
 * 
 * Describes an 'exploded' FRU file, where each area
 * is a set of text strings, easy for human comprehension and manipulation.
 *
 * This is the main type that all library API functions operate on.
 */
typedef struct {
	bool present[FRU_TOTAL_AREAS]; ///< Area presence flags
	char *internal; ///< Internal use area. In exploded view this is just a hex string.
	fru_chassis_t chassis; ///< The chassis information structure
	fru_board_t board; ///< The board information structure
	fru_product_t product; ///< The product information structure
	fru_mr_reclist_t *mr_reclist; ///< The multirecord area as a linked list of records
} fru_t;

/**
 * @brief Debug flags to FRU decoding functions.
 *
 * Sometimes some vendors make errors in their FRU info files.
 * These flags are needed to ignore those possible errors and
 * load as much information as possible. Without these flags,
 * the fru_loadfile() and fru_loadbuffer() will fail immediately
 * upon detection of an error in the input.
 */
typedef enum {
	FRU_NOFLAGS = 0, /**< No flags, operate normally */
	FRU_IGNFVER = FRU__BIT(0), /**< Ignore FRU version in FRU header */
	FRU_IGNFHCKSUM = FRU__BIT(1), /**< Ignore FRU header checksum */
	FRU_IGNFDCKSUM = FRU__BIT(2), /**< Ignore FRU data checksum */
	FRU_IGNAVER = FRU__BIT(3), /**< Ignore area version */
	FRU_IGNRVER = FRU__BIT(4), /**< Ignore record version for
	                           *    multirecord area */
	FRU_IGNACKSUM = FRU__BIT(5), /**< Ignore area checksum */
	FRU_IGNRHCKSUM = FRU__BIT(6), /**< Ignore record header checksum
	                              * for multirecord area */
	FRU_IGNRDCKSUM = FRU__BIT(7), /**< Ignore record data checksum
	                              *   for multirecord area */
	FRU_IGNRNOEOL = FRU__BIT(8), /**< Ignore absence of EOL-flagged
	                             *   MR area record, use any previous
	                             *   valid records */
	FRU_IGNBIG = FRU_BIT(9), /**< Don't fail on binary file load if
	                          *   the file is bigger than 64K,
	                          *   attempt to load it anyway (may be dangerous) */
	FRU_IGNAEOF = FRU_BIT(10), /**< Ignore no end-of-fields marker in info areas */
} fru_flags_t;

/** Table 16-2, MultiRecord Area Record Types
 *
 * The \p ASF_* types are per Alert Standard Format Spec rev 2.0 (DSP0136).
 *
 * The \p NVME_* types are per NVME-MI Spec rev 1.2b, section 8.2.
 * 
 * @addtogroup multirec MultiRecord area
 * @brief Definitions related to MultiRecord Area
 * @{
 */
typedef enum {
	FRU_MR_EMPTY = -1, /**< MR Record is empty, will be skipped during saving */
	FRU_MR_MIN = 0x00, /**< The minimum valid MR record type that can be saved */
	FRU_MR_PSU_INFO = 0x00, /**< PSU Information */
	FRU_MR_DC_OUT = 0x01, /**< DC Output */
	FRU_MR_DC_LOAD = 0x02, /**< DC Load */
	FRU_MR_MGMT_ACCESS = 0x03, /**< Management Access Record */
	FRU_MR_BCR = 0x04, /**< Base Compatibility Record */
	FRU_MR_ECR = 0x05, /**< Extended Compatibility Record */

	FRU_MR_ASF_FIXED_SMBUS = 0x06, /**< ASF Fixed SMBus Addresses */
	FRU_MR_ASF_LEGACY_ALERTS = 0x07, /**< ASF Lecacy-Device Alerts */
	FRU_MR_ASF_REMOTE_CTRL = 0x08, /**< ASF Remote Control */

	FRU_MR_EXT_DC_OUT = 0x09, /**< Extended DC Output */
	FRU_MR_EXT_DC_LOAD = 0x0A, /**< Extended DC Load */

	FRU_MR_NVME = 0x0B, /**< NVMe Information */
	FRU_MR_NVME_PCIE_PORT = 0x0C, /**< NVMe PCIe Port */
	FRU_MR_NVME_TOPOLOGY = 0x0D, /**< NVMe Topolgy */
	FRU_MR_NVME_RSVD_E = 0x0E, /**< Reserved */
	FRU_MR_NVME_RSVD_F = 0x0F, /**< Reserved */

	FRU_MR_OEM_START = 0xC0, /**< Start of OEM range */
	FRU_MR_OEM_END = 0xFF, /**< End of OEM range */
	FRU_MR_MAX = FRU_MR_OEM_END, /**< The maximum valid MR record type that can be saved */
	FRU_MR_TYPE_COUNT /**< Total number of MR record types */
} fru_mr_type_t;

/** @cond PRIVATE */
#define FRU__FILE_MRR_MAXDATA (UINT8_MAX) /**< Maximum length of MR record data (encoded) */
/** @endcond */

/** Maximum length of OEM MR record data in decoded form (NUL-terminated hex string) */
#define FRU_MRR_OEM_MAXDATA (FRU__FILE_MRR_MAXDATA * 2 + 1)

/// Table 18-6, Management Access Record
typedef enum {
	FRU_MR_MGMT_INVALID = 0x00, /**< Invalid subtype, do not use */
	FRU_MR_MGMT_MIN = 0x01,
	FRU_MR_MGMT_SYS_URL = 0x01,  /**< System URL */
	FRU_MR_MGMT_SYS_NAME = 0x02, /**< System Name */
	FRU_MR_MGMT_SYS_PING = 0x03, /**< System Ping Address */
	FRU_MR_MGMT_COMPONENT_URL = 0x04,  /**< Component URL */
	FRU_MR_MGMT_COMPONENT_NAME = 0x05, /**< Component Name */
	FRU_MR_MGMT_COMPONENT_PING = 0x06, /**< Component Ping Address */
	FRU_MR_MGMT_SYS_UUID = 0x07, /**< System Unique ID */
	FRU_MR_MGMT_MAX = FRU_MR_MGMT_SYS_UUID,
} fru_mr_mgmt_type_t;

/// NVMe Form-Factor, see NVMe-MI Spec rev 1.2b, Figure 160
/// Not yet implemented
typedef enum {
	FRU_NVME_FF_UNKNOWN = 0,
} fru_nvme_ff_t;

/** @cond PRIVATE */
#define MGMT_TYPE_ID(type) ((type) - FRU_MR_MGMT_MIN)
#define MGMT_TYPENAME_ID(name) MGMT_TYPE_ID(FRU_MR_MGMT_##name)
#define FRU__MR_MGMT_HDR_LEN (1) /* Just the subtype byte length */
/** @endcond */

/** Maximum length of data in MR Management Access record
 *
 * All management subtype records are plain text strings,
 * and even UUID, which is binary, in decoded form is
 * represented as a sting of 32 hex digits, which is at
 * least twice less than the maximum length for any of the
 * plain text subtypes.
 *
 * Hence, encoded and decoded lengths for plain text strings
 * are the same, we just use the max encoded length here
 */
#define FRU_MR_MGMT_MAXDATA (FRU__FILE_MRR_MAXDATA - FRU__MR_MGMT_HDR_LEN) 

/**
 * @brief MultiRecord area record type
 *
 * Describes a record of any supported multirecord area record type
 * in decoded form. Comprises a number of type-specific structs
 * combined in a union. You only need to fill in the fields of the struct
 * that correspond to the selected record \a type.
 *
 * All byte arrays are stored as hex strings in this structure.
 * All integer types are stored as host-endian integers.
 * All string types are stored as C-strings.
 *
 * \b Example
 *
 * ```
 * fru_mr_rec_t rec = {};
 * const int mr_myoem_type = FRU_MR_OEM_START + 1;
 *
 * rec.type = mr_myoem_type;
 * rec.oem.type = FRU_FIELD_TYPE_TEXT;
 * strncpy(rec.oem.data, "Some OEM data", sizeof(rec.oem.data));
 *
 * // Alternatively:
 *
 * rec.type = mr_myoem_type;
 * rec.oem.type = FRU_FIELD_TYPE_BINARY;
 * strncpy(rec.oem.data, "01020304DEADC0DE", sizeof(rec.oem.data));
 * ```
 */
typedef struct {
	fru_mr_type_t type; /**< Record Type */
	union {
		/** PSU Information, see IPMI FRU spec section 18.1 */
		/** TODO: Not yet implemented */
		struct {
		} psu;
		/** DC Output, see IPMI FRU spec section 18.2 */
		/** TODO: Not yet implemented */
		struct {
		} dco;
		/** Extended DC Output, see IPMI FRU spec section 18.2a */
		/** TODO: Not yet implemented */
		struct {
		} edco;
		/** DC Load, see IPMI FRU spec section 18.3 */
		/** TODO: Not yet implemented */
		struct {
		} dcl;
		/** Extended DC Load, see IPMI FRU spec section 18.3a */
		/** TODO: Not yet implemented */
		struct {
		} edcl;
		/** Management Access Record, see IPMI FRU spec section 18.4 */
		struct {
			/** Management Access Record subtype */
			fru_mr_mgmt_type_t subtype;

			/** Management Access Record data.
			 *
			 * Most data in this type of record are just plain text strings.
			 * The "System GUID" (UUID) subtype data is binary, but as usual for
			 * libfru, a hex string representation is expected/stored here.
			 *
			 * \note The "System GUID" (\ref FRU_MR_MGMT_SYS_UUID) data string
			 *       is expected to be Big-Endian on input, and will be stored
			 *       here in the same format on output. The generated binary
			 *       file output will use SMBIOS-compatible Little-Endian
			 *       encoding, and the same encoding is expected from an input
			 *       binary FRU file.
			 */
			char data[FRU_MR_MGMT_MAXDATA + 1]; /* 1 byte for terminator */
		} mgmt;
		/** Base Compatibility Record, see IPMI FRU spec section 18.5 */
		/** TODO: Not yet implemented */
		struct {
		} bcr;
		/** Extended Compatibility Record, see IPMI FRU spec section 18.6 */
		/** TODO: Not yet implemented */
		struct {
		} ecr;
		/** Alert Standard Format records, see ASF spec (DSP0136), revision 2.0 */
		/** TODO: Not yet implemented */
		struct {
			union {
				/** Fixed SMBus Addresses, see section 4.3.1 */
				/** TODO: Not yet implemented */
				struct {
				} smbus;
				/** Legacy-Device Alerts, see section 4.3.2 */
				/** TODO: Not yet implemented */
				struct {
				} legacy;
				/** Remote Control, see section 4.3.3 */
				/** TODO: Not yet implemented */
				struct {
				} rc;
			};
		} asf;

		/** NVMe Records, see NVMe-MI specification revision 1.2b */
		/** TODO: Not yet implemented */
		struct {
			union {
				/** NVMe Record, see section 8.2.3 */
				/** TODO: Not yet implemented */
				struct {
					fru_nvme_ff_t formfactor; /**< Form-Factor as per NVMe-MI 1.2b Figure 160 */
					uint8_t p1v8_init;
					uint8_t p1v8_max;
					uint8_t p3v3_init;
					uint8_t p3v3_max;
					uint8_t p3v3_aux_max;
					uint8_t p5v_init;
					uint8_t p5v_max;
					uint8_t p12v_init;
					uint8_t p12v_max;
					uint8_t ptherm_max;
					uint64_t capacity_lo; /**< Total capacity, higher 8 bytes, 13:6 of 13, host-endian */
					uint32_t capacity_mid; /**< Total capacity, middle 4 bytes, 5:2 of 13, host-endian */
					uint8_t capacity_hi; /**< Total capacity, middle 4 bytes, 1 of 13 */
				} info;
				/** NVMe PCIe Port Record, see section 8.2.4 */
				/** TODO: Not yet implemented */
				struct {
				} pcie;
				/** NVMe Topology Record, see section 8.2.4 */
				/** TODO: Not yet implemented */
				struct {
				} topology;
			};
		} nvme;

		/** OEM Record, see IPMI FRU spec section 18.7 */
		/** TODO: Not yet implemented */
		struct {
			fru_field_type_t type; /**< OEM data encoding type.
									*
									* Supported are:
									*   - \ref FIELD_TYPE_TEXT (plain text, Latin1 only, auto \a len)
									*   - \ref FIELD_TYPE_BINARY (hex string data)
									*
									* Functions fru_load_file() and fru_load_buffer() always autodetect
									* the encoding of OEM records, and set the \a type field accordingly.
									*/
			char * data[FRU_MRR_OEM_MAXDATA]; /**< OEM data */
		} oem;
	};
} fru_mr_rec_t;

/**
 * @brief A single-linked list of decoded FRU MR area records.
 *
 * This is used to describe any length chains of MR records.
 */
typedef struct fru_mr_reclist_s {
	fru_mr_rec_t * rec; ///< A pointer to a record or NULL if not initialized
	struct fru_mr_reclist_s * next; ///< The next record in the list or NULL if last
} fru_mr_reclist_t;

#define FRU_LIST_HEAD 0 /** Add entry at the head of the list, used by fru_add_mr() */
#define FRU_LIST_TAIL INT_MAX /** Add entry at the end of the list, used by fru_add_mr() */
/** @} */

/*
 * Public function definitions
 */

/**
 * @addtogroup common
 * @brief Common definitions for the library
 *
 * @{
 */

/**
 * @brief Load FRU information from a binary file.
 *
 * Takes a binary FRU information file (e.g. EEPROM dump or the output of
 * `ipmitool fru read`, and loads it as a fru_t structure for further
 * modification.
 *
 * If \a fru is \p NULL, then a new FRU structure is allocated, otherwise
 * the supplied one will be filled in, and the existing values will be
 * overwritten with the contents of the file. The function will fail if \a
 * fru->internal, \a mru->rc_reclist, or any of the \p cust lists in the info
 * area members of \a fru are non-NULL.
 *
 * Supported are:
 *  - All generic info areas (chassis, board, product),
 *    including the custome fields (decoded as hex strings)
 *  - Internal Use area (decoded as hex string)
 *  - Multirecord area:
 *    - Management Access record:
 *      - System Unique ID (UUID), treated as per SMBIOS definition,
 *        decoded as a big-endian hex string
 *      - All other MA types, as plain text strings
 *
 * @param[in, out] fru Pointer to an initial FRU structure (can be \p NULL)
 * @param[in] filename Name of the file to load
 * @param[in] flags flags or FRU_NOFLAGS
 *
 * @returns A pointer to the filled in fru_t structure.
 * @retval NULL Error detected. \p fru_errno is set accordingly.
 */
fru_t * fru_loadfile(fru_t * fru,
                     const char *filename,
                     fru_flags_t flags);

/**
 * @brief Load FRU information from a binary file.
 *
 * Same as fru_loadfile(), but takes a binary buffer as input.
 * In fact, fru_loadfile() calls this one under the hood
 * after memory-mapping the binary FRU file.
 *
 * @param[in, out] fru Pointer to an initial FRU structure (can be \p NULL)
 * @param[in] buf Buffer containing a binary FRU information file
 * @param[in] size Buffer size
 * @param[in] flags Debug flags or \ref FRU_NOFLAGS
 *
 * @returns A pointer to the filled in fru_t structure.
 * @retval NULL Error detected. \p fru_errno is set accordingly.
 */
fru_t * fru_loadbuffer(fru_t * fru,
                       const void *buf,
                       size_t size,
                       fru_flags_t flags);


/**
 * @brief Free the contents of a fru_t structure
 *
 * Will free any memory allocated by fru_loadfile(), fru_loadbuffer(),
 * fru_add_mr(), and fru_add_custom() functions for the members
 * of \a fru. Any deallocated members will be set to NULL.
 *
 * Will not free \a fru itself to allow for static allocation of the
 * top-level structure. If it was dynamically allocated (e.g, by
 * a call to fru_loadfile() with \p NULL for \a fru argument), then
 * are to explicitly call \p free() on it after calling fru_free().
 *
 * @param[in, out] fru Pointer to a FRU structure to free
 */
void fru_free(fru_t * fru);

/**
 * @brief TODO: Encode a FRU info structure into a binary buffer
 *
 * If buf is NULL, allocates a new one.
 * Always calculates the resulting size and stores it at \p size.
 *
 * @param[in] fru The FRU information structure to encode/export
 * @param[in,out] buf Pointer to a buffer to containing the
 *                    binary FRU information file (allocated if NULL)
 * @param[in,out] size Pointer to the size of the output buffer
 *                     (size is adjusted upon return to the actual
 *                     size of the encoded data).
 *                     The input value pointed to by \p size can
 *                     be 0 if \p buf is NULL.
 *
 * @returns Encoding status
 * @retval true Encoded successfully, \p size adjusted.
 * @retval false Failed to encode. \p fru_errno is set accordingly.
 */
bool fru_savebuffer(const fru_t * fru, void ** buf, size_t * size);

/**
 * @brief TODO: Encode a FRU info structure into a binary file
 *
 * Creates/overwrites the specified file with the encoded FRU info
 * data. Calls fru_savebuffer() under the hood.
 *
 * @param[in] fru The decoded FRU information structure to encode
 * @param[in] fname Name of the file to create
 *
 * @returns Success status
 * @retval true Encoded and written successfully.
 * @retval false Failed to encode or write, \p fru_errno is set accordingly.
 */
bool fru_savefile(const fru_t * fru, const char * fname);

/**
 * @brief TODO: Deallocate a FRU info structure
 *
 * Deletes/deallocates a FRU info structure previously created with
 * \ref fru_loadfile() or \ref fru_loadbuffer(). Also deallocates all
 * custom fields, as well as internal use area and multirecord area records,
 * if any. No need to delete them separately.
 *
 * Sets \a fru to NULL upon successful deletion.
 *
 * @param[in] fru Pointer to the decoded FRU information structure to delete
 *
 * @returns Success status
 * @retval true Deleted successfully.
 * @retval false Failed to delete, \p fru_errno is set accordingly.
 */
bool fru_delete(const fru_t ** fru);

/**
 * @brief TODO: Copy string to the given field, perform length check
 *        according to selected encoding, truncate if needed
 *
 * Attempt will be made to encode the input string using the requested
 * encoding. The string will be truncated to fit and the event will be
 * indicated via \ref fru_errno as \ref FELONGINPUT along with success
 * return code. Please set \ref fru_errno to 0 before the call to avoid
 * false positive checks for truncation.
 *
 * If \p encoding is \ref FIELD_TYPE_PRESERVE, then the function will
 * use the encoding set in \p field->encoding.
 * 
 * @param[in, out] field     Pointer to a decoded field (typically inside a
 *                           member of fru_t)
 * @param[in]      encoding  Desired encoding.
 * @param[in]      string    The input string to set the field to.
 * @returns Success status
 * @retval true Success, check \ref fru_errno for \ref FELONGINPUT to
 *              see if data was truncated
 * @retval false Failure, \ref fru_errno is set to one of:
 *               - \ref FERANGE
 *               - \ref FENONPRINT
 *               - \ref FENONHEX
 *               - \ref FENOTEVEN
 *               - \ref FEBADENC
 */
bool fru_setfield(fru_decoded_field_t * field,
                  field_type_t encoding,
                  const char * string);

/**
 * @brief Add a custom field to the given area type in the
 *        given fru structure
 *
 * Allocates a new custom fields list entry for the given area
 * type within the decoded fru structure and calls fru_setfield()
 * on it with the given input string.
 *
 * The new record is added/inserted at the given index in the list.
 *
 * @param[in] fru The decoded FRU information structure to modify.
 * @param[in] index Index in the custom record list at which to add the new
 *                  record. Specify \ref FRU_LIST_TAIL to add the new
 *                  record at the end of the list, or \ref FRU_LIST_HEAD
 *                  to insert it at the head.
 * @param[in] atype Type of the area to modify in \p fru. Only supports
 *                  areas that can have custom fields by specification,
 *                  namely:
 *                  - \ref FRU_CHASSIS_INFO
 *                  - \ref FRU_BOARD_INFO
 *                  - \ref FRU_PRODUCT_INFO
 * @param[in] encoding Desired encoding. Can't use \ref FIELD_TYPE_PRESERVE here.
 *                     Use only the \a standard encodings here.
 * @param[in] string The input string to add as a custom field.
 *
 * @returns Success status, see \ref fru_setfield() for details
 * @retval true Success
 * @retval false Failure, additionally may set \ref fru_errno to:
 *               - \ref FEAREANOTSUP
 *               - \ref FEAREABADTYPE
 */
bool fru_add_custom(fru_t * fru,
                    size_t index,
                    fru_area_type_t atype,
                    fru_field_type_t encoding,
                    const char * string);

/**
 * @brief TODO: Get a pointer to a custom data field in the area of the
 *        given type in the given fru structure
 *
 * Finds the custom field at the given index and returns a pointer
 * to it, so that \ref fru_setfield() could be used on it.
 *
 * @param[in] fru The decoded FRU information structure to modify.
 * @param[in] atype Type of the area to modify in \p fru. Only supports
 *                  areas that can have custom fields by specification,
 *                  namely:
 *                  - \ref FRU_CHASSIS_INFO
 *                  - \ref FRU_BOARD_INFO
 *                  - \ref FRU_PRODUCT_INFO
 * @param[in] index The index of the custom field to fetch
 *
 * @returns A pointer to the custom field at the requested index or \a NULL
 *          in the event of failure. For the latter case \ref fru_errno is set to:
 *           - \ref FEAREANOTSUP
 *           - \ref FEAREABADTYPE
 *           - \ref FENOFIELD
 */
decoded_field_t * fru_get_custom(fru_t * fru,
                                 fru_area_type_t atype,
                                 size_t index);

/**
 * @brief TODO: Delete a custom data field in the area of the
 *        given type in the given fru structure
 *
 * Finds the custom field at the given index and deletes it
 * from the list, deallocates memory.
 *
 * @param[in] fru The decoded FRU information structure to modify.
 * @param[in] atype Type of the area to modify in \p fru. Only supports
 *                  areas that can have custom fields by specification,
 *                  namely:
 *                  - \ref FRU_CHASSIS_INFO
 *                  - \ref FRU_BOARD_INFO
 *                  - \ref FRU_PRODUCT_INFO
 * @param[in] index The index of the custom field to fetch
 *
 * @returns Success status
 * @retval true The requested cusom field has been deleted
 * @retval false There was an error, see \ref fru_errno :
 *                - \ref FEAREANOTSUP
 *                - \ref FEAREABADTYPE
 *                - \ref FENOFIELD
 */
bool fru_delete_custom(fru_t * fru,
                       fru_area_type_t atype,
                       size_t index);

/**
 * @brief Set internal use area from binary buffer
 *
 * Converts contents of the provided binary buffer into
 * a hex string and copies them into \a fru->internal, allocating
 * or reallocating the latter as needed. Updates \a fru->present[FRU_INTERNAL_USE]
 * on success or, on failure, leaves it and \a fru->internal as they were.
 *
 * @param[in] fru The decoded FRU information structure to modify.
 * @param[in] buffer Source binary buffer
 * @param[in] size Number of bytes in \a buffer
 *
 * @returns Success status
 * @retval true Success
 * @retval false Failure, \a fru unmodified, check \ref fru_errno
 */
bool fru_set_internal_binary(fru_t * fru, const void * buffer, size_t size);

/**
 * @brief Set internal use area from a hex string
 *
 * Copies contents of the provided hex string into
 * internal use area of the the given FRU info structure.
 * Allocates a new buffer for that, the original \a buffer may
 * safely be deallocated after the call.
 *
 * On success will allocate or reallocate internal use area in \a fru as needed
 * and will update the presence flag for the area in \a fru.
 *
 * On failure will leave \a fru completely unmodified.
 
 * The source string must contain only hex digits and optional delimiters
 * that will be skipped during copying. Supported delimiters are:
 *
 *  - space ' '
 *  - dot '.'
 *  - dash '-'
 *  - colon ':'
 *
 * Any other symbols will result in a failure.
 * 
 * @b Example
 * ```
 * fru_set_internal_hexstring(fru, "1337C0DE");
 * ```
 *
 * @param[in] fru The decoded FRU information structure to modify.
 * @param[in] hexstr The source hex string
 *
 * @returns Success status
 * @retval true Success
 * @retval false Failure, \a fru left unmodified, check \ref fru_errno
 */
bool fru_set_internal_hexstring(fru_t * fru, const void * hexstr);

/**
 * @brief TODO: Delete internal use area from FRU structure
 *
 * Deallocates the internal use area and removes it from the
 * given FRU info structure.
 *
 * @param[in] fru The decoded FRU information structure to modify.
 *
 * @returns Success status
 * @retval true Success
 * @retval false Failure, sets \ref fru_errno
 */
bool fru_delete_internal(fru_t * fru);

/**
 * @brief TODO: Add a multirecord area record
 *
 * Allocates a new multirecord area record structure, adds it to the
 * given FRU info structure, and fills it with provided data.
 * You may discard/free the source \a rec after a successfull call
 * to this function.
 *
 * @param[in, out] fru The decoded FRU information structure to modify.
 * @param[in] index Index in the MR record list at which to add the new
 *                  record. Specify \ref FRU_LIST_TAIL to add the new
 *                  record at the end of the list, or \ref FRU_LIST_HEAD
 *                  to insert it at the head.
 * @param[in] rec The decoded MultiRecord area record structure to add.
 *                If \p NULL, an empty record of \ref FRU_MR_EMPTY type
 *                is added.
 *
 * @returns A pointer to the allocated record inside the MR area
 * @retval NULL Failure, sets \ref fru_errno
 */
fru_mr_rec_t * fru_add_mr(fru_t * fru, size_t index, fru_mr_rec_t * rec);

/**
 * @brief TODO: Get a multirecord area record at the given index
 *
 * Finds the record at the given index in the MultiRecord area
 * and returns a pointer to it or \a NULL if not found.
 * 
 * \b Hint
 *
 * You may use index 0 to check if the MR area is empty:
 * ```
 * if (!fru_get_mr(fru, 0)) {
 *     // MR area is empty!
 * }
 * ```
 * 
 * @param[in] fru The decoded FRU information structure to search.
 * @param[in] index Index of the MultiRecord area record to fetch
 *
 * @returns A pointer to the found record inside the MR area
 * @retval NULL Failure, sets \ref fru_errno
 */
fru_mr_rec_t * fru_get_mr(fru_t * fru, size_t index);

/**
 * @brief TODO: Find a multirecord area record of the given type
 *
 * Finds the record at in the MultiRecord area using the record
 * \p type and the starting \p index. Updates \p index when the
 * record is found, sets it to the index of the next record.
 * If the found record was the last in the list, then sets
 * \ref fru_errno to \ref FEMREND.
 *
 * @param[in] fru The decoded FRU information structure to search.
 * @param[in] type Type of the record to search for.
 * @param[in, out] index Starting index of the MultiRecord area record
 *                       to begin the search with.
 *
 * @returns A pointer to the found record inside the MR area
 * @retval NULL Failure, sets \ref fru_errno, doesn't update \p index
 */
fru_mr_rec_t * fru_find_mr(fru_t * fru, fru_mr_type_t type, size_t &index);

/**
 * @brief TODO: Replace a multirecord area record at the given index
 *
 * Finds the record at the given index in the MultiRecord area,
 * and replaces its contents with those from the provided structure.
 *
 * @param[in, out] fru The decoded FRU information structure to modify.
 * @param[in] index Index of the record to replace
 * @param[in] rec The decoded MultiRecord area record structure to use
 *                instead of the found one
 *
 * @returns Success status
 * @retval true Success
 * @retval false Failure, sets \ref fru_errno
 */
bool fru_replace_mr(fru_t * fru, size_t index, fru_mr_rec_t * rec);

/**
 * @brief TODO: Delete a multirecord area record at the given index
 *
 * Finds the record at the given index in the MultiRecord area,
 * and deletes.
 *
 * @param[in] fru The decoded FRU information structure to modify.
 * @param[in] index Index of the record to replace
 *
 * @returns Success status
 * @retval true Success
 * @retval false Failure, sets \ref fru_errno
 */
bool fru_delete_mr(const fru_t * fru, size_t index);

/* @} */

#if 0


#endif

#if 0 // Old header

#include <errno.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <sys/time.h>

#endif
